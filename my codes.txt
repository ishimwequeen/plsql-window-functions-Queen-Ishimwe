-- Customers table
CREATE TABLE customers (
    customer_id NUMBER PRIMARY KEY,
    name VARCHAR(100),
    region VARCHAR(50)
);

-- Products table  
CREATE TABLE products (
    product_id NUMBER PRIMARY KEY,
    name VARCHAR2(100),
    category VARCHAR2(50)
);

-- Transactions table
CREATE TABLE transactions (
    transaction_id NUMBER PRIMARY KEY,
    customer_id NUMBER,
    product_id NUMBER,
    sale_date DATE,
    amount NUMBER(10,2),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);
-- Insert sample customers
INSERT INTO customers VALUES (1001, 'John Mugisha', 'Kigali', DATE '2023-01-15');
INSERT INTO customers VALUES (1002, 'Marie Uwase', 'Northern', DATE '2023-02-20');
INSERT INTO customers VALUES (1003, 'Peter Habimana', 'Southern', DATE '2023-03-10');

-- Insert sample products
INSERT INTO products VALUES (2001, 'Rwandan Coffee Beans', 'Beverages', 15000);
INSERT INTO products VALUES (2002, 'Traditional Basket', 'Handicrafts', 25000);
INSERT INTO products VALUES (2003, 'Banana Beer', 'Beverages', 8000);

-- Insert sample transactions
INSERT INTO transactions VALUES (3001, 1001, 2001, DATE '2024-01-15', 2, 30000);
INSERT INTO transactions VALUES (3002, 1002, 2002, DATE '2024-01-20', 1, 25000);
-- Rank customers by total spending
SELECT 
    customer_name,
    SUM(total_amount) as total_spent,
    ROW_NUMBER() OVER (ORDER BY SUM(total_amount) DESC) as row_num,
    RANK() OVER (ORDER BY SUM(total_amount) DESC) as revenue_rank,
    DENSE_RANK() OVER (ORDER BY SUM(total_amount) DESC) as dense_rank
FROM customers c
JOIN transactions t ON c.customer_id = t.customer_id
GROUP BY customer_name;

-- Rank products within each category
SELECT 
    product_name,
    prod_category,
    SUM(quantity) as units_sold,
    RANK() OVER (PARTITION BY prod_category ORDER BY SUM(quantity) DESC) as category_rank,
    PERCENT_RANK() OVER (PARTITION BY prod_category ORDER BY SUM(quantity) DESC) as percentile
FROM products p
JOIN transactions t ON p.product_id = t.product_id
GROUP BY product_name, prod_category;

-- Rank months by sales performance
SELECT 
    DATE_FORMAT(trans_date, '%Y-%m') as month,
    SUM(total_amount) as monthly_sales,
    RANK() OVER (ORDER BY SUM(total_amount) DESC) as sales_rank,
    DENSE_RANK() OVER (ORDER BY SUM(total_amount) DESC) as dense_sales_rank
FROM transactions
GROUP BY DATE_FORMAT(trans_date, '%Y-%m');

-- Rank payment methods by usage
SELECT 
    type_name as payment_method,
    COUNT(transaction_id) as usage_count,
    ROW_NUMBER() OVER (ORDER BY COUNT(transaction_id) DESC) as popularity_rank,
    PERCENT_RANK() OVER (ORDER BY COUNT(transaction_id) DESC) as usage_percentile
FROM transactions t
JOIN transaction_type tt ON t.type_id = tt.type_id
GROUP BY type_name;

-- Rank customers by number of visits
SELECT 
    customer_name,
    COUNT(transaction_id) as visit_count,
    RANK() OVER (ORDER BY COUNT(transaction_id) DESC) as frequency_rank,
    DENSE_RANK() OVER (ORDER BY COUNT(transaction_id) DESC) as dense_freq_rank
FROM customers c
JOIN transactions t ON c.customer_id = t.customer_id
GROUP BY customer_name;
2. Aggregate Functions

-- Calculate running total of sales
SELECT 
    trans_date,
    SUM(total_amount) as daily_sales,
    SUM(SUM(total_amount)) OVER (ORDER BY trans_date ROWS UNBOUNDED PRECEDING) as running_total
FROM transactions
GROUP BY trans_date
ORDER BY trans_date;

-- Calculate 3-day moving average of sales
SELECT 
    trans_date,
    SUM(total_amount) as daily_sales,
    AVG(SUM(total_amount)) OVER (ORDER BY trans_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as moving_avg_3d
FROM transactions
GROUP BY trans_date
ORDER BY trans_date;

-- Find min and max sales values per product
SELECT 
    product_name,
    MIN(total_amount) as min_sale,
    MAX(total_amount) as max_sale,
    AVG(total_amount) as avg_sale
FROM transactions t
JOIN products p ON t.product_id = p.product_id
GROUP BY product_name;

-- Compare ROWS vs RANGE framing
SELECT 
    DATE_FORMAT(trans_date, '%Y-%m') as month,
    SUM(total_amount) as monthly_sales,
    AVG(SUM(total_amount)) OVER (ORDER BY DATE_FORMAT(trans_date, '%Y-%m') ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) as rows_avg,
    AVG(SUM(total_amount)) OVER (ORDER BY DATE_FORMAT(trans_date, '%Y-%m') RANGE BETWEEN 1 PRECEDING AND CURRENT ROW) as range_avg
FROM transactions
GROUP BY DATE_FORMAT(trans_date, '%Y-%m');

-- Cumulative average spending per customer
SELECT 
    customer_name,
    trans_date,
    total_amount,
    AVG(total_amount) OVER (PARTITION BY c.customer_id ORDER BY trans_date ROWS UNBOUNDED PRECEDING) as cumulative_avg
FROM transactions t
JOIN customers c ON t.customer_id = c.customer_id
ORDER BY customer_name, trans_date;
3. Navigation Functions

-- Calculate monthly growth percentage
WITH monthly_sales AS (
    SELECT 
        DATE_FORMAT(trans_date, '%Y-%m') as month,
        SUM(total_amount) as sales
    FROM transactions
    GROUP BY DATE_FORMAT(trans_date, '%Y-%m')
)
SELECT 
    month,
    sales,
    LAG(sales, 1) OVER (ORDER BY month) as prev_month,
    ROUND(((sales - LAG(sales, 1) OVER (ORDER BY month)) / LAG(sales, 1) OVER (ORDER BY month)) * 100, 2) as growth_pct
FROM monthly_sales;

-- Find next purchase date for each customer
SELECT 
    customer_name,
    trans_date,
    total_amount,
    LEAD(trans_date, 1) OVER (PARTITION BY c.customer_id ORDER BY trans_date) as next_purchase_date
FROM transactions t
JOIN customers c ON t.customer_id = c.customer_id
ORDER BY customer_name, trans_date;

-- Compare each day's sales with previous day
SELECT 
    trans_date,
    SUM(total_amount) as daily_sales,
    LAG(SUM(total_amount), 1) OVER (ORDER BY trans_date) as prev_day_sales,
    SUM(total_amount) - LAG(SUM(total_amount), 1) OVER (ORDER BY trans_date) as daily_change
FROM transactions
GROUP BY trans_date
ORDER BY trans_date;

-- Analyze product sales trend with lead/lag
SELECT 
    product_name,
    trans_date,
    quantity,
    LAG(quantity, 1) OVER (PARTITION BY p.product_id ORDER BY trans_date) as prev_quantity,
    LEAD(quantity, 1) OVER (PARTITION BY p.product_id ORDER BY trans_date) as next_quantity
FROM transactions t
JOIN products p ON t.product_id = p.product_id
ORDER BY product_name, trans_date;

-- Analyze customer spending pattern over time
SELECT 
    customer_name,
    trans_date,
    total_amount,
    LAG(total_amount, 1) OVER (PARTITION BY c.customer_id ORDER BY trans_date) as prev_amount,
    LEAD(total_amount, 1) OVER (PARTITION BY c.customer_id ORDER BY trans_date) as next_amount
FROM transactions t
JOIN customers c ON t.customer_id = c.customer_id
ORDER BY customer_name, trans_date;


4. Distribution Functions

-- Segment customers into 4 quartiles by spending
SELECT 
    customer_name,
    SUM(total_amount) as total_spent,
    NTILE(4) OVER (ORDER BY SUM(total_amount) DESC) as spending_quartile
FROM customers c
JOIN transactions t ON c.customer_id = t.customer_id
GROUP BY customer_name;


-- Analyze product performance using percentiles
SELECT 
    product_name,
    SUM(total_amount) as total_revenue,
    CUME_DIST() OVER (ORDER BY SUM(total_amount)) as cumulative_distribution,
    ROUND(CUME_DIST() OVER (ORDER BY SUM(total_amount)) * 100, 2) as percentile
FROM products p
JOIN transactions t ON p.product_id = t.product_id
GROUP BY product_name;

-- Segment customers by visit frequency
SELECT 
    customer_name,
    COUNT(transaction_id) as visit_count,
    NTILE(4) OVER (ORDER BY COUNT(transaction_id) DESC) as frequency_segment
FROM customers c
JOIN transactions t ON c.customer_id = t.customer_id
GROUP BY customer_name;

-- Analyze payment method distribution
SELECT 
    type_name as payment_method,
    COUNT(transaction_id) as usage_count,
    CUME_DIST() OVER (ORDER BY COUNT(transaction_id)) as cumulative_dist
FROM transactions t
JOIN transaction_type tt ON t.type_id = tt.type_id
GROUP BY type_name;

-- Segment products by price range
SELECT 
    product_name,
    selling_price,
    NTILE(4) OVER (ORDER BY selling_price) as price_quartile,
    CUME_DIST() OVER (ORDER BY selling_price) as price_percentile
FROM products;